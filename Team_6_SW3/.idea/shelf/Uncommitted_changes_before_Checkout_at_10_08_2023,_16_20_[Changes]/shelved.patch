Index: models/piece.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>white_pieces = ['rook', 'knight', 'bishop', 'king', 'queen', 'bishop', 'knight', 'rook', 'pawn', 'pawn', 'pawn', 'pawn',\n                'pawn', 'pawn', 'pawn', 'pawn']\nwhite_locations = [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0),\n                   (0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1)]\n\nblack_pieces = ['rook', 'knight', 'bishop', 'king', 'queen', 'bishop', 'knight', 'rook', 'pawn', 'pawn', 'pawn', 'pawn',\n                'pawn', 'pawn', 'pawn', 'pawn']\nblack_locations = [(0, 7), (1, 7), (2, 7), (3, 7), (4, 7), (5, 7), (6, 7), (7, 7),\n                   (0, 6), (1, 6), (2, 6), (3, 6), (4, 6), (5, 6), (6, 6), (7, 6)]\n\ncaptured_pieces_white = []\ncaptured_pieces_black = []\n\n# function to check all pieces valid options on board\ndef check_options(pieces, locations, turn):\n    moves_list = []\n    all_moves_list = []\n    for i in range((len(pieces))):\n        location = locations[i]\n        piece = pieces[i]\n        if piece == 'pawn':\n            moves_list = check_pawn(location, turn)\n        elif piece == 'rook':\n            moves_list = check_rook(location, turn)\n        elif piece == 'knight':\n            moves_list = check_knight(location, turn)\n        elif piece == 'bishop':\n            moves_list = check_bishop(location, turn)\n        elif piece == 'queen':\n            moves_list = check_queen(location, turn)\n        elif piece == 'king':\n            moves_list = check_king(location, turn)\n        all_moves_list.append(moves_list)\n    return all_moves_list\n\n\n# check king valid moves\ndef check_king(position, color):\n    moves_list = []\n    if color == 'white':\n        enemies_list = black_locations\n        friends_list = white_locations\n    else:\n        friends_list = black_locations\n        enemies_list = white_locations\n    # 8 squares to check for kings moves, they can go one square in any direction\n    targets = [(1, 0), (1, 1), (1, -1), (-1, 0), (-1, 1), (-1, -1), (0, 1), (0, -1)]\n    for i in range(8):\n        target = (position[0] + targets[i][0], position[1] + targets[i][1])\n        if target not in friends_list and 0 <= target[0] <= 7 and 0 <= target[1] <= 7:\n            moves_list.append(target)\n\n    return moves_list\n\n\n# check queen valid moves\ndef check_queen(position, color):\n    moves_list = check_bishop(position, color)\n    second_list = check_rook(position, color)\n    for i in range(len(second_list)):\n        moves_list.append(second_list[i])\n    return moves_list\n\n\n# check bishop moves\ndef check_bishop(position, color):\n    moves_list = []\n    if color == 'white':\n        enemies_list = black_locations\n        friends_list = white_locations\n    else:\n        friends_list = black_locations\n        enemies_list = white_locations\n    for i in range(4):  # up-right, up-left, down-right, down-left\n        path = True\n        chain = 1\n        if i == 0:\n            x = 1\n            y = -1\n        elif i == 1:\n            x = -1\n            y = -1\n        elif i == 2:\n            x = 1\n            y = 1\n        else:\n            x = -1\n            y = 1\n        while path:\n            if (position[0] + (chain * x), position[1] + (chain * y)) not in friends_list and \\\n                    0 <= position[0] + (chain * x) <= 7 and 0 <= position[1] + (chain * y) <= 7:\n                moves_list.append((position[0] + (chain * x), position[1] + (chain * y)))\n                if (position[0] + (chain * x), position[1] + (chain * y)) in enemies_list:\n                    path = False\n                chain += 1\n            else:\n                path = False\n    return moves_list\n\n\n# check rook\ndef check_rook(position, color):\n    moves_list = []\n    if color == 'white':\n        enemies_list = black_locations\n        friends_list = white_locations\n    else:\n        friends_list = black_locations\n        enemies_list = white_locations\n    for i in range(4):  # down, up, right, left\n        path = True\n        chain = 1\n        if i == 0:\n            x = 0\n            y = 1\n        elif i == 1:\n            x = 0\n            y = -1\n        elif i == 2:\n            x = 1\n            y = 0\n        else:\n            x = -1\n            y = 0\n        while path:\n            if (position[0] + (chain * x), position[1] + (chain * y)) not in friends_list and \\\n                    0 <= position[0] + (chain * x) <= 7 and 0 <= position[1] + (chain * y) <= 7:\n                moves_list.append((position[0] + (chain * x), position[1] + (chain * y)))\n                if (position[0] + (chain * x), position[1] + (chain * y)) in enemies_list:\n                    path = False\n                chain += 1\n            else:\n                path = False\n    return moves_list\n\n\n# check valid pawn moves\ndef check_pawn(position, color):\n    moves_list = []\n    if color == 'white':\n        if (position[0], position[1] + 1) not in white_locations and \\\n                         (position[0], position[1] + 1) not in black_locations and position[1] < 7:\n            moves_list.append((position[0], position[1] + 1))\n        if (position[0], position[1] + 2) not in white_locations and (position[0], position[1] + 2) \\\n                not in black_locations and position[1] == 1:\n            moves_list.append((position[0], position[1] + 2))\n        if (position[0] + 1, position[1] + 1) in black_locations:\n            moves_list.append((position[0], position[1] + 1))\n        if (position[0] - 1, position[1] + 1) in black_locations:\n            moves_list.append((position[0] - 1, position[1] + 1))\n    else:\n        if (position[0], position[1] - 1) not in white_locations and \\\n                         (position[0], position[1] - 1) not in black_locations and position[1] > 0:\n            moves_list.append((position[0], position[1] - 1))\n        if (position[0], position[1] - 2) not in white_locations and (position[0], position[1] + 2) \\\n                not in black_locations and position[1] == 6:\n            moves_list.append((position[0], position[1] - 2))\n        if (position[0] + 1, position[1] - 1) in white_locations:\n            moves_list.append((position[0] + 1, position[1] - 1))\n        if (position[0] - 1, position[1] - 1) in white_locations:\n            moves_list.append((position[0] - 1, position[1] - 1))\n    return moves_list\n\n\n# check knight moves\ndef check_knight(position, color):\n    moves_list = []\n    if color == 'white':\n        enemies_list = black_locations\n        friends_list = white_locations\n    else:\n        friends_list = black_locations\n        enemies_list = white_locations\n    # 8 squares to check for knights moves, they can go two squares in one direction and one in another direction\n    targets = [(1, 2), (1, -2), (2, 1), (2, -1), (-1, 2), (-1, -2), (-2, 1), (-2, -1)]\n    for i in range(8):\n        target = (position[0] + targets[i][0], position[1] + targets[i][1])\n        if target not in friends_list and 0 <= target[0] <= 7 and 0 <= target[1] <= 7:\n            moves_list.append(target)\n    return moves_list\n\n\n\n# game loop\nblack_options = check_options(black_pieces, black_locations, 'black')\nwhite_options = check_options(white_pieces, white_locations, 'white')\nrun = True\nwhile run:\n    timer.tick(fps)\n    screen.fill('dark gray')\n    draw_board()\n    draw_pieces()\n    draw_captured()\n    if selection != 100:\n        valid_moves = check_valid_moves()\n        draw_valid(valid_moves)\n\n# event handling\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            run = False\n        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1 and not game_over:\n            x_coord = event.pos[0] // 100  # x coord\n            y_coord = event.pos[1] // 100  # y coord\n            click_coords = (x_coord, y_coord)\n            if turn_step <= 1:\n                if click_coords == (8, 8) or click_coords == (9, 8):\n                    winner = 'black'\n                if click_coords in white_locations:\n                    selection = white_locations.index(click_coords)  # piece location we want the index of that piece\n                    if turn_step == 0:\n                        turn_step = 1\n                if click_coords in valid_moves and selection != 100:  # don't want to be able to click somewhere and\n                    # move without a piece selected\n                    white_locations[selection] = click_coords  # the piece is allowed to go to where is selected\n                    if click_coords in black_locations:  # checking it takes us to where a black piece is sitting\n                        black_piece = black_locations.index(click_coords)\n                        captured_pieces_white.append(black_pieces[black_piece])\n                        if black_pieces[black_piece] == 'king':\n                            winner = 'white'\n                        black_pieces.pop(black_piece)\n                        black_locations.pop(black_piece)\n                    black_options = check_options(black_pieces, black_locations, 'black')\n                    white_options = check_options(white_pieces, white_locations, 'white')\n                    turn_step = 2\n                    selection = 100\n                    valid_moves = []\n            if turn_step > 1:\n                if click_coords == (8, 8) or click_coords == (9, 8):\n                    winner = 'white'\n                if click_coords in black_locations:\n                    selection = black_locations.index(click_coords)  # piece location we want the index of that piece\n                    if turn_step == 2:\n                        turn_step = 3\n                if click_coords in valid_moves and selection != 100:  # don't want to be able to click somewhere and\n                    # move without a piece selected\n                    black_locations[selection] = click_coords  # the piece is allowed to go to where is selected\n                    if click_coords in white_locations:  # checking it takes us to where a black piece is sitting\n                        white_piece = white_locations.index(click_coords)\n                        captured_pieces_black.append(white_pieces[white_piece])\n                        if black_pieces[white_piece] == 'king':\n                            winner = 'black'\n                        white_pieces.pop(white_piece)\n                        white_locations.pop(white_piece)\n                    black_options = check_options(black_pieces, black_locations, 'black')\n                    white_options = check_options(white_pieces, white_locations, 'white')\n                    turn_step = 0\n                    selection = 100\n                    valid_moves = []\n        if event.type == pygame.KEYDOWN and game_over:\n            if event.key == pygame.K_RETURN:\n                game_over = False\n                winner = ''\n                white_pieces = ['rook', 'knight', 'bishop', 'king', 'queen', 'bishop', 'knight', 'rook', 'pawn', 'pawn',\n                                'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn']\n                white_locations = [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0),\n                                   (0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1)]\n                black_pieces = ['rook', 'knight', 'bishop', 'king', 'queen', 'bishop', 'knight', 'rook', 'pawn', 'pawn',\n                                'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn']\n                black_locations = [(0, 7), (1, 7), (2, 7), (3, 7), (4, 7), (5, 7), (6, 7), (7, 7),\n                                   (0, 6), (1, 6), (2, 6), (3, 6), (4, 6), (5, 6), (6, 6), (7, 6)]\n                captured_pieces_white = []\n                captured_pieces_black = []\n                turn_step = 0\n                selection = 100  # variable for what index piece is currently selected\n                valid_moves = []  # list to check valid moves\n                black_options = check_options(black_pieces, black_locations, 'black')\n                white_options = check_options(white_pieces, white_locations, 'white')\n\n\n    if winner != '':\n        game_over = True\n        draw_game_over()
===================================================================
diff --git a/models/piece.py b/models/piece.py
--- a/models/piece.py	
+++ b/models/piece.py	
@@ -1,3 +1,5 @@
+import pygame
+
 white_pieces = ['rook', 'knight', 'bishop', 'king', 'queen', 'bishop', 'knight', 'rook', 'pawn', 'pawn', 'pawn', 'pawn',
                 'pawn', 'pawn', 'pawn', 'pawn']
 white_locations = [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0),
@@ -181,19 +183,19 @@
 
 
 
-# game loop
-black_options = check_options(black_pieces, black_locations, 'black')
-white_options = check_options(white_pieces, white_locations, 'white')
-run = True
-while run:
-    timer.tick(fps)
-    screen.fill('dark gray')
-    draw_board()
-    draw_pieces()
-    draw_captured()
-    if selection != 100:
-        valid_moves = check_valid_moves()
-        draw_valid(valid_moves)
+# # game loop
+# black_options = check_options(black_pieces, black_locations, 'black')
+# white_options = check_options(white_pieces, white_locations, 'white')
+# run = True
+# while run:
+#     timer.tick(fps)
+#     screen.fill('dark gray')
+#     draw_board()
+#     draw_pieces()
+#     draw_captured()
+#     if selection != 100:
+#         valid_moves = check_valid_moves()
+#         draw_valid(valid_moves)
 
 # event handling
     for event in pygame.event.get():
